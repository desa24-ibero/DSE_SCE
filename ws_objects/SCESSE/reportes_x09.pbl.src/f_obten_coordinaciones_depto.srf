$PBExportHeader$f_obten_coordinaciones_depto.srf
global type f_obten_coordinaciones_depto from function_object
end type

forward prototypes
global function integer f_obten_coordinaciones_depto (ref long al_cve_division[], ref long al_coordinaciones[])
end prototypes

global function integer f_obten_coordinaciones_depto (ref long al_cve_division[], ref long al_coordinaciones[]);//f_obten_coordinaciones_depto
//		al_cve_division			long
//		al_coordinaciones[]		long

long ll_row_actual, ll_clave, ll_num_registros
long ll_tamanio_array, ll_indice_array, ll_cve_division, ll_indice_coordinaciones = 1
string ls_texto, ls_datawindow = 'd_coordinaciones'
uds_datastore lds_datastore

lds_datastore = create uds_datastore
lds_datastore.dataobject= ls_datawindow
lds_datastore.SetTransObject(gtr_sce)

ll_tamanio_array = upperBound(al_cve_division)

FOR ll_indice_array = 1 TO ll_tamanio_array
	ll_cve_division = al_cve_division[ll_indice_array]
	ll_num_registros = lds_datastore.Retrieve(ll_cve_division)
	if ll_num_registros >0 then
		for ll_row_actual= 1 to ll_num_registros	
			ll_clave = lds_datastore.GetItemNumber(ll_row_actual,1)
			al_coordinaciones[ll_indice_coordinaciones]= ll_clave	
			ll_indice_coordinaciones = ll_indice_coordinaciones +1
		next	
	elseif ll_num_registros< 0 then
		MessageBox("Datastore con error", "El datastore["+ls_datawindow+"] no puede devuelve registros", StopSign!)
		return -1
	end if
NEXT

return ll_indice_coordinaciones + 1
end function

